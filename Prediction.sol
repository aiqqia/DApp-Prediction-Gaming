pragma solidity ^0.5.0;

contract Prediction {
    address predictionSystem;
    bool isOpen;
    uint256 numberOfOptions;
    mapping(address => uint256) chosenOption; //Options are zero-indexed
    mapping(uint256 => string) optionName;
    mapping(uint256 => uint256) totalTokensPerOption;
    mapping(address => uint256) viewerTokensOnOption;

    constructor(uint256 _numberOfOptions) public {
        // Since this contract is meant to be created by the PredictionSystem contract, we store msg.sender as the PredictionSystem contract address
        predictionSystem = msg.sender;
        numberOfOptions = _numberOfOptions;
        isOpen = true;
    }

    modifier validOption(uint256 selectedOption) {
        require(selectedOption < numberOfOptions, "Invalid option");
        require(selectedOption > 0);
        _;
    }

    modifier predictionOpen() {
        require(isOpen, "Prediction is closed");
        _;
    }

    modifier validPredictionAmount(uint256 predictionAmount) {
        require(predictionAmount > 0, "Prediction amount must be greater than 0");
        // To add check for msg.sender to have sufficient tokens
        // require(predictionAmount <= tokenSupply[msg.sender])
        _;
    }

    //To add modifier to allow for mods/streamer only
    modifier onlyStreamerOrMods() {
        _;
    }

    function betOnOpenOption(uint256 option, uint256 tokens) public predictionOpen() validOption(option) validPredictionAmount(tokens) {
        // To add a check for msg.sender to have sufficient tokens
        chosenOption[msg.sender] = option;
        viewerTokensOnOption[msg.sender] = tokens;
        totalTokensPerOption[option] += tokens;
    }

    function betOnClosedOption(uint256 option) public validOption(option) {
        // Betting on closed option does not require a token bet

        // Check if user previously made a bet on open prediction
        if (viewerTokensOnOption[msg.sender] > 0) {
            // If user previously made a bet on open prediction, subtract the tokens from the totalTokensPerOption
            totalTokensPerOption[chosenOption[msg.sender]] -= viewerTokensOnOption[msg.sender];
        }
        // Update chosen option by user
        chosenOption[msg.sender] = option;
        viewerTokensOnOption[msg.sender] = 0;
    }

    function setOption(uint256 option, string memory name) public onlyStreamerOrMods() validOption(option) {
        optionName[option] = name;
    }

    function getPrediction(address viewer) public view returns(uint256) {
        // Allow address of NULL to check themselves
        if (viewer == address(0)) {
            return chosenOption[msg.sender];
        }
        return chosenOption[viewer];
    }

    function getTotalTokensPerOption(uint256 option) public view validOption(option) returns(uint256) {
        return totalTokensPerOption[option];
    }

    function getPredictionAmount(address viewer) public view returns(uint256) {
        // Allow address of NULL to check themselves
        if (viewer == address(0)) {
            return viewerTokensOnOption[msg.sender];
        }
        return viewerTokensOnOption[viewer];
    }

    //TO TEST OUT THE FUNCTION (generated by Copilot)
    function getPredictionList() public view returns(string memory) {
        string memory predictionList;
        // convert optionName to string with comma separated values
        for (uint256 i = 0; i < numberOfOptions; i++) {
            predictionList = string(abi.encodePacked(predictionList, optionName[i], ","));
        }
        
        return predictionList;
    }
}

