pragma solidity ^0.5.0;
import "./PredictionSystem.sol"; 
import "./StreamerChannel.sol";

contract Prediction {
    address predictionSystem;
    address streamerChannelContract;
    bool isOpen;
    uint256 numberOfOptions;
    mapping(uint256 => string) optionName;

    constructor(uint256 _numberOfOptions, address streamerContractAddress) public {
        // Since this contract is meant to be created by the PredictionSystem contract, we store msg.sender as the PredictionSystem contract address
        predictionSystem = msg.sender;
        streamerChannelContract = streamerContractAddress;
        numberOfOptions = _numberOfOptions;
        isOpen = true;
    }

    modifier validOption(uint256 selectedOption) {
        require(selectedOption < numberOfOptions, "Invalid option");
        require(selectedOption > 0);
        _;
    }

    //To add modifier to allow for mods/streamer only
    modifier onlyStreamerOrMods(address _address) {
        require(streamerChannelContract.isStreamerOrMods(_address));
        _;
    }

    function betOnOpenOption(uint256 option, uint256 tokens) public {
        // To add a check for msg.sender to have sufficient tokens
        predictionSystem.betOnOpenOption(option, tokens);
    }

    function betOnClosedOption(uint256 option) public {
        // Betting on closed option does not require a token bet
        predictionSystem.betOnClosedOption(option);
    }

    function setOptionName(uint256 option, string memory name) public onlyStreamerOrMods(msg.sender) validOption(option) {
        optionName[option] = name;
    }

    //TO TEST OUT THE FUNCTION (generated by Copilot)
    function getPredictionList() public view returns(string memory) {
        string memory predictionList;
        // convert optionName to string with comma separated values
        for (uint256 i = 0; i < numberOfOptions; i++) {
            predictionList = string(abi.encodePacked(predictionList, optionName[i], ","));
        }
        
        return predictionList;
    }
}

